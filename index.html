<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Train Departures Test</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    pre { background: #f4f4f4; padding: .5rem; border-radius: 4px; }
    .error { color: red; }
  </style>
</head>
<body>
  <h1>Live Trains from Nõmme</h1>
  <div id="clock"></div>
  <pre id="output">Loading…</pre>

  <script>
    // 📡 Correct GraphQL endpoint:
    const GRAPHQL_URL = 'https://api.digitransit.fi/routing/v2/finland/gtfs/v1';

    // 1) Live clock
    function tick() {
      document.getElementById('clock').textContent =
        'Local time: ' + new Date().toLocaleTimeString('et-EE');
    }
    setInterval(tick, 1000);
    tick();

    // 2) Generic fetch helper
    async function gqlFetch(query, variables, operationName) {
      const res = await fetch(GRAPHQL_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query, variables, operationName })
      });
      const json = await res.json();
      console.log('raw response', json);
      if (json.errors) throw new Error(json.errors.map(e => e.message).join('; '));
      if (!json.data)  throw new Error('no data in response');
      return json.data;
    }

    // 3) Find GTFS stop ID for “Nõmme”
    async function getStopId(name) {
      const query = `
        query GetStops($q: String!) {
          stops(name: $q) { gtfsId name }
        }
      `;
      const data = await gqlFetch(query, { q: name }, 'GetStops');
      if (!data.stops.length) throw new Error('no stops found for ' + name);
      return data.stops[0].gtfsId;
    }

    // 4) Fetch next departures
    async function getDepartures(stopId, limit = 10) {
      const query = `
        query GetTimes($id: String!, $n: Int!) {
          stop(id: $id) {
            name
            stoptimesWithoutPatterns(numberOfDepartures: $n) {
              scheduledDeparture
              realtimeDeparture
              departureDelay
              trip { route { mode } }
            }
          }
        }
      `;
      return await gqlFetch(query, { id: stopId, n: limit }, 'GetTimes');
    }

    // 5) Render
    (async () => {
      try {
        const stopId = await getStopId('Nõmme');
        const { name, stoptimesWithoutPatterns } = await getDepartures(stopId, 20);
        const nowSec = new Date().getHours()*3600 + new Date().getMinutes()*60;
        const upcoming = stoptimesWithoutPatterns
          .filter(st => st.trip.route.mode === 'RAIL')
          .filter(st => (st.realtimeDeparture || st.scheduledDeparture) >= nowSec)
          .slice(0,5)
          .map(st => {
            const sec = st.realtimeDeparture ?? st.scheduledDeparture;
            const hh = String(Math.floor(sec/3600)).padStart(2,'0');
            const mm = String(Math.floor((sec%3600)/60)).padStart(2,'0');
            const status = st.departureDelay > 0
              ? `+${st.departureDelay} min delay`
              : 'On time';
            return `${hh}:${mm}  (${status})`;
          });

        document.getElementById('output').textContent =
          upcoming.length
            ? `Departures from ${name}:\n\n` + upcoming.join('\n')
            : 'No upcoming rail departures found.';
      } catch (e) {
        document.getElementById('output').textContent = 'Error: ' + e.message;
        document.getElementById('output').classList.add('error');
        console.error(e);
      }
    })();
  </script>
</body>
</html>
