<!DOCTYPE html>
<html lang="et">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>ðŸš† Live Train Departures</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0 }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex; flex-direction: column; align-items: center;
      padding: 2rem; background: #f0f2f5; color: #333;
    }
    h1 { margin-bottom: 1rem; }
    #clock { margin-bottom: 1rem; font-weight: bold; }
    #output {
      width: 100%; max-width: 400px;
      background: white; padding: 1rem; border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      white-space: pre-wrap; font-family: monospace;
    }
    .error { color: #c00; }
  </style>
</head>
<body>
  <h1>ðŸš† NÃµmme â†’ Tallinn</h1>
  <div id="clock">â€¦</div>
  <div id="output">Loading departuresâ€¦</div>

  <script>
    // ðŸ“¡ Digitransit GraphQL endpoint (Finland & Estonia)
    const GRAPHQL_URL = 'https://api.digitransit.fi/routing/v2/finland/gtfs/v1';

    // 1) Live clock
    function updateClock() {
      const now = new Date();
      document.getElementById('clock').textContent =
        'Local time: ' + now.toLocaleTimeString('et-EE');
    }
    setInterval(updateClock, 1000);
    updateClock();

    // 2) Helper to POST a GraphQL query
    async function gqlFetch(query, variables, operationName) {
      const resp = await fetch(GRAPHQL_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query, variables, operationName })
      });
      const json = await resp.json();
      if (json.errors) {
        throw new Error(json.errors.map(e => e.message).join('; '));
      }
      if (!json.data) {
        throw new Error('No data in response');
      }
      return json.data;
    }

    // 3) Look up GTFS stop ID for the given name
    async function getStopId(name) {
      const query = `
        query GetStops($q: String!) {
          stops(name: $q) { gtfsId name }
        }
      `;
      const data = await gqlFetch(query, { q: name }, 'GetStops');
      if (!data.stops.length) {
        throw new Error('Stop not found: ' + name);
      }
      return data.stops[0].gtfsId;
    }

    // 4) Fetch upcoming stoptimes
    async function getDepartures(stopId, limit = 10) {
      const query = `
        query GetTimes($id: String!, $n: Int!) {
          stop(id: $id) {
            name
            stoptimesWithoutPatterns(numberOfDepartures: $n) {
              scheduledDeparture
              realtimeDeparture
              departureDelay
              trip { route { mode } }
            }
          }
        }
      `;
      return await gqlFetch(query, { id: stopId, n: limit }, 'GetTimes');
    }

    // 5) Convert secondsâ€sinceâ€midnight to "HH:MM"
    function secsToHM(sec) {
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
    }

    // 6) Orchestrate everything
    (async () => {
      const out = document.getElementById('output');
      try {
        const stopId = await getStopId('NÃµmme');
        const { name, stoptimesWithoutPatterns } =
          await getDepartures(stopId, 20);

        // filter for rail & departures â‰¥ now
        const nowSec = new Date().getHours()*3600 + new Date().getMinutes()*60;
        const upcoming = stoptimesWithoutPatterns
          .filter(st => st.trip.route.mode === 'RAIL')
          .filter(st => (st.realtimeDeparture || st.scheduledDeparture) >= nowSec)
          .slice(0, 5)
          .map(st => {
            const sec = st.realtimeDeparture ?? st.scheduledDeparture;
            const time = secsToHM(sec);
            const status = st.departureDelay > 0
              ? `+${st.departureDelay} min delay`
              : 'On time';
            return `${time}  (${status})`;
          });

        out.textContent = upcoming.length
          ? `Departures from ${name}:\n\n` + upcoming.join('\n')
          : 'No upcoming rail departures found.';
      } catch (err) {
        out.textContent = 'Error: ' + err.message;
        out.classList.add('error');
        console.error(err);
      }
    })();
  </script>
</body>
</html>
